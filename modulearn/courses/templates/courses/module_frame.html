{% extends 'content_base.html' %}
{% load static %}

{% block content %}
<div id="module-frame-container">
  {{ state_data|json_script:"state-data" }}

  <!-- Debug template variables -->
  <!-- selected_protocol: {{ selected_protocol }} -->
  <!-- content_url: {{ content_url }} -->
  <!-- use_proxy: {{ use_proxy }} -->

  <!-- Fallback UI for tools that refuse iframe embedding -->
  <div id="iframe-blocked-notice" class="{% if not refuses_iframe %}hidden{% endif %} p-8 text-center bg-gray-50 dark:bg-gray-800 rounded-lg mx-4 my-4">
    <h3 class="text-red-500 text-xl font-bold mb-4">⚠️ This tool cannot be embedded</h3>
    <p class="text-gray-500 dark:text-gray-400 mb-4">
      {% if refuses_iframe_reason %}
        {{ refuses_iframe_reason }}
      {% else %}
        The external tool has security restrictions that prevent it from loading in an iframe.
      {% endif %}
    </p>
    <button id="open-in-new-window"
            onclick="window.open('{{ iframe_src|escapejs }}', '_blank')"
            class="btn btn-primary btn-lg">
      Open in New Window →
    </button>
    <p class="text-gray-400 text-sm mt-4">
      Note: Progress may not be tracked when opened in a new window.
    </p>
  </div>

  <iframe id="content-iframe"
          src="{% if not refuses_iframe %}{{ iframe_src }}{% endif %}"
          width="100%"
          height="800px"
          frameborder="0"
          allowfullscreen
          allow="clipboard-write *"
          {% if refuses_iframe %}class="hidden"{% endif %}>
    Your browser doesn't support iframes.
  </iframe>
</div>

<script>
  const selectedProtocol = "{{ selected_protocol|default:'' }}";
  const contentUrl = "{{ content_url|escapejs }}";
  const useProxy = {{ use_proxy|yesno:"true,false" }};
  const iframeSrc = "{{ iframe_src|escapejs }}";
  const moduleId = {{ module.id }};



  const isPreview = {{ preview_mode|yesno:"true,false" }};

  // CSP / Iframe Load Error Detection
  let iframeLoaded = false;
  const iframe = document.getElementById('content-iframe');
  const blockedNotice = document.getElementById('iframe-blocked-notice');

  iframe.addEventListener('load', function() {
    iframeLoaded = true;
    probeSplice();
    setTimeout(probeSplice, 1000);
    setTimeout(probeSplice, 3000);
  });

  document.addEventListener('securitypolicyviolation', function(e) {
    // Check if this is a frame-ancestors violation (iframe blocking)
    if (e.violatedDirective === 'frame-ancestors' || 
        e.violatedDirective.includes('frame-ancestors') ||
        (e.blockedURI && iframeSrc && e.blockedURI.includes(new URL(iframeSrc).hostname))) {
      showBlockedNotice(
        `This tool cannot be embedded in an iframe due to Content Security Policy restrictions. ` +
        `The tool only allows framing from specific origins. ` +
        `Please use the "Open in New Window" button below to access this activity.`
      );
    }
  });
  
  // Check for iframe load errors
  iframe.addEventListener('error', function(e) {
    setTimeout(function() {
      try {
        const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
        if (!iframeDoc || !iframeDoc.body || iframeDoc.body.innerHTML.trim() === '') {
          showBlockedNotice(
            `The tool failed to load. This may be due to Content Security Policy restrictions. ` +
            `Please use the "Open in New Window" button below to access this activity.`
          );
        }
      } catch (e) {
        // Cross-origin - can't check
      }
    }, 2000);
  });

  function showBlockedNotice(reason) {
    blockedNotice.classList.remove('hidden');
    iframe.classList.add('hidden');
  }

  function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }

  function probeSplice() {
    const iframe = document.getElementById('content-iframe');
    if (!iframe || !iframe.contentWindow) {
      return;
    }
    const probes = [
      { subject: 'SPLICE.getState', message_id: uuid() },
      { subject: 'SPLICE.ping', message_id: uuid() },
      { subject: 'SPLICE.hello', message_id: uuid() },
    ];
    for (const msg of probes) {
      iframe.contentWindow.postMessage(msg, '*');
    }
  }

  window.addEventListener('message', function(event) {
    // Parse message data - handle both object and string formats
    let messageData = event.data;
    if (typeof messageData === 'string') {
      try {
        messageData = JSON.parse(messageData);
      } catch (e) {
        // Not JSON, keep as string
      }
    }
    
    const data = messageData;

    const expectedOrigins = new Set([
      window.location.origin,
      'https://codecheck.me', 'https://codecheck.io',
      'http://adapt2.sis.pitt.edu', 'http://pawscomp2.sis.pitt.edu', 'http://columbus.exp.sis.pitt.edu',
      'https://adapt2.sis.pitt.edu', 'https://pawscomp2.sis.pitt.edu', 'https://columbus.exp.sis.pitt.edu',
      'https://pcrs.utm.utoronto.ca/',
      'https://acos.cs.vt.edu',
    ]);

    const isExpectedOrigin = expectedOrigins.has(event.origin);
    if (!isExpectedOrigin) {
      return;
    }

    // Handle SPLICE.getState request
    if (data && typeof data === 'object' && data.subject === 'SPLICE.getState') {
      const stateScript = document.getElementById('state-data');
      let storedState = stateScript ? JSON.parse(stateScript.textContent) : null;
      if (storedState) {
        if (typeof storedState === 'string') storedState = JSON.parse(storedState);
        const response = {
          subject: 'SPLICE.getState.response',
          message_id: data.message_id,
          state: storedState
        };
        document.getElementById('content-iframe').contentWindow.postMessage(response, event.origin);
      }
      return;
    }

    // Handle LTI frame resize
    if (data && typeof data === 'object' && data.subject === 'lti.frameResize') {
      return;
    }

    // Handle SPLICE.reportScoreAndState
    if (data && typeof data === 'object' && data.subject === 'SPLICE.reportScoreAndState') {
      if (isPreview) {
        return;
      }

      let progress = 0;
      if (data.state && data.state.scoreText) {
        const scoreText = data.state.scoreText;
        if (scoreText.includes('/')) {
          const [completed, total] = scoreText.split('/').map(num => parseInt(num));
          progress = (completed / total) * 100;
        }
      }

      const progressData = {
        data: [{
          activityId: '{{ module.id }}',
          completion: data.score === 1.0,
          score: (data.score || 0) * 100,
          success: (data.score || 0) >= 0.7,
          progress: progress,
          response: data.state
        }]
      };

      fetch('{% url "courses:update_module_progress" module.id %}', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-CSRFToken': '{{ csrf_token }}' },
        body: JSON.stringify(progressData)
      })
      .then(response => response.json())
      .catch(error => {
        console.error('Error updating progress:', error);
      });
      return;
    }

    // Handle SPLICE.sendEvent (event logging only, no progress update)
    if (data && typeof data === 'object' && data.subject === 'SPLICE.sendEvent') {
      return;
    }
  });
</script>

{% csrf_token %}
{% endblock %}
